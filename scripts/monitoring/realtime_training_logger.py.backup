#!/usr/bin/env python3
"""
실시간 학습 로그 캡처 시스템

- tee 명령어로 stdout을 파일과 화면에 동시 출력
- WebSocket으로 브라우저에 실시간 스트리밍
- 로그 파일에 영구 저장
- 처음부터 끝까지 모든 출력 캡처
"""

import os
import sys
import time
import asyncio
import subprocess
from pathlib import Path
from datetime import datetime, timezone, timedelta
from typing import Optional, List
import json

# FastAPI 및 WebSocket
from fastapi import FastAPI, WebSocket, WebSocketDisconnect
from fastapi.responses import HTMLResponse
import uvicorn
import asyncio
from pathlib import Path

class RealtimeTrainingLogger:
    """실시간 학습 로그 캡처 및 스트리밍"""
    
    def __init__(self, log_file: Optional[str] = None):
        # 실제 Python 학습 로그 파일 경로 자동 감지
        if log_file is None:
            log_file = self._detect_latest_log_file()
        
        self.log_file = log_file
        print(f"📝 로그 파일 경로: {self.log_file}")
        
        # bash_23 출력을 실시간으로 파일에 기록하는 프로세스 시작
        self._start_bash23_capture()
        self.connected_clients: List[WebSocket] = []
        self.training_process: Optional[subprocess.Popen] = None
        self.last_position = 0  # 파일 읽기 위치 추적
    
    def _detect_latest_log_file(self) -> str:
        """실제 Python 학습 로그 파일 자동 감지"""
        import glob
        import os
        from datetime import datetime
        
        # bash_23 출력 파일을 최우선으로 확인
        bash23_log = "/tmp/stage3_bash23_output.log"
        if os.path.exists(bash23_log) and os.path.getsize(bash23_log) > 0:
            print(f"✅ bash_23 로그 파일 사용: {bash23_log}")
            return bash23_log
        
        # 가능한 로그 경로들 (우선순위별)
        log_patterns = [
            # 로그 파일 경로 패턴들 (실제 core.py에서 생성되는 경로)
            "/home/max16/pillsnap_data/exp/exp01/logs/__main___*.log",
            "/home/max16/pillsnap_data/exp/exp01/logs/src.training.train_stage3_two_stage_*.log", 
            "/home/max16/pillsnap_data/exp/exp01/logs/*train*_*.log",
            "/home/max16/pillsnap_data/exp/*/logs/__main___*.log",
            "/home/max16/pillsnap_data/exp/*/logs/*train*_*.log",
            # 백업 경로
            "/tmp/pillsnap_training_*.log",
            "/tmp/stage3_training.log",
            "/tmp/stage3_live.log"
        ]
        
        latest_file = None
        latest_time = 0
        
        for pattern in log_patterns:
            files = glob.glob(pattern)
            for file in files:
                try:
                    mtime = os.path.getmtime(file)
                    if mtime > latest_time and os.path.getsize(file) > 0:  # 빈 파일 제외
                        latest_time = mtime
                        latest_file = file
                except (OSError, IOError):
                    continue
        
        if latest_file:
            print(f"✅ 최신 로그 파일 발견: {latest_file}")
            return latest_file
        else:
            # 기본 로그 파일 생성
            default_log = f"/tmp/pillsnap_training_{datetime.now().strftime('%Y%m%d')}.log"
            print(f"⚠️ 로그 파일을 찾을 수 없음. 기본 경로 사용: {default_log}")
            return default_log
        
    def _start_bash23_capture(self):
        """bash_23의 실제 stdout을 캡처해서 실시간 브로드캐스트"""
        import threading
        import asyncio
        
        # 현재 상태 추적 변수들 (기존)
        self.current_epoch = 3
        self.current_batch = "진행중"  
        self.current_loss = "감소중"
        self.classification_acc = "N/A"
        self.detection_map = "N/A" 
        self.epoch_time = "N/A"
        
        # Phase 1 새로운 지표 추적 변수들
        self.top1_accuracy = "N/A"
        self.top5_accuracy = "N/A"
        self.macro_f1 = "N/A"
        self.single_domain_acc = "N/A"
        self.combination_domain_acc = "N/A"
        self.det_latency = "N/A"
        self.crop_latency = "N/A"
        self.cls_latency = "N/A"
        self.total_latency = "N/A"
        self.det_confidence = "N/A"
        self.cls_confidence = "N/A"
        self.oom_old_batch = "N/A"
        self.oom_new_batch = "N/A"
        self.oom_old_accum = "N/A"
        self.oom_new_accum = "N/A"
        self.det_steps = "N/A"
        self.cls_steps = "N/A"
        self.interleave_ratio = "N/A"
        
        # 확장된 Phase 1 지표들 (요구사항 반영)
        # 도메인별 Top-5 / Macro-F1
        self.single_top1 = "N/A"
        self.single_top5 = "N/A"
        self.single_macro_f1 = "N/A"
        self.combo_top1 = "N/A"
        self.combo_top5 = "N/A"
        self.combo_macro_f1 = "N/A"
        
        # Detection Recall / Precision
        self.det_recall = "N/A"
        self.det_precision = "N/A"
        
        # 도메인별 Selected Confidence
        self.selected_conf_single = "N/A"
        self.selected_conf_combo = "N/A"
        
        # 레이턴시 퍼센타일 (p50/p95/p99)
        self.latency_p50_det = "N/A"
        self.latency_p95_det = "N/A"
        self.latency_p99_det = "N/A"
        self.latency_p50_crop = "N/A"
        self.latency_p95_crop = "N/A"
        self.latency_p99_crop = "N/A"
        self.latency_p50_cls = "N/A"
        self.latency_p95_cls = "N/A"
        self.latency_p99_cls = "N/A"
        self.latency_p50_total = "N/A"
        self.latency_p95_total = "N/A"
        self.latency_p99_total = "N/A"
        
        # VRAM Peak / Grad-Norm
        self.vram_peak_mb = "N/A"
        self.grad_norm_after = "N/A"
        
        # 동적 학습 설정 추적
        self.total_epochs = 50  # 기본값 (Stage 3)
        self.total_batches = 5093  # 기본값
        
        def capture_bash23():
            """bash_23의 실제 stdout을 캡처하고 실시간 브로드캐스트"""
            import time
            import subprocess
            import re
            
            # bash_23에서 확인된 현재 상태로 초기화
            self.current_epoch = 4
            self.current_batch = "2000/5093"
            self.current_loss = "3.5000"
            self.classification_acc = "0.086"
            self.detection_map = "0.250"
            self.epoch_time = "635.0s"
            
            # tail -f로 로그 파일 실시간 감시
            print(f"📂 로그 파일 감시 시작: {self.log_file}")
            tail_process = subprocess.Popen(
                ["tail", "-f", "-n", "100", self.log_file],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                universal_newlines=True,
                bufsize=0
            )
            
            while True:
                try:
                    # tail -f에서 한 줄 읽기
                    line = tail_process.stdout.readline()
                    if not line:
                        time.sleep(0.1)
                        continue
                    
                    # 로그 파싱
                    try:
                        # KST 시간대로 로그 시간 표시
                        kst = timezone(timedelta(hours=9))
                        current_time = datetime.now(kst).strftime('%H:%M:%S')
                        log_line = None
                        
                        if not line.strip():
                            continue
                            
                        # === 확장된 파서: Phase 1 로깅 포맷 대응 ===
                        
                        # 1) 기존 Epoch X | Batch Y/5093 | Loss: Z 패턴 파싱
                        batch_match = re.search(r'Epoch\s+(\d+)\s+\|\s+Batch\s+(\d+)/(\d+)\s+\|\s+Loss:\s+([\d.]+)', line)
                        if batch_match:
                            epoch, current_batch, total_batches, loss = batch_match.groups()
                            self.current_epoch = int(epoch)
                            self.current_batch = f"{current_batch}/{total_batches}"
                            self.current_loss = loss
                            log_line = f"{current_time} | INFO | Epoch {epoch} | Batch {current_batch}/{total_batches} | Loss: {loss}"
                        
                        # 2) 기존 Cls Acc: X | Det mAP: Y | Time: Z 패턴 파싱
                        acc_match = re.search(r'Cls Acc:\s+([\d.]+)\s+\|\s+Det mAP:\s+([\d.]+)\s+\|\s+Time:\s+([\d.]+)s', line)
                        if acc_match:
                            cls_acc, det_map, epoch_time = acc_match.groups()
                            self.classification_acc = cls_acc
                            self.detection_map = det_map
                            self.epoch_time = f"{epoch_time}s"
                            log_line = f"{current_time} | INFO | Epoch {self.current_epoch} 완료 | Cls Acc: {cls_acc} | Det mAP: {det_map} | Time: {epoch_time}s"
                        
                        # === 새로운 Phase 1 포맷 파서들 ===
                        
                        # 3) Top-5 정확도: "Top-1: 0.441 | Top-5: 0.672"
                        top5_match = re.search(r'Top-1:\s*([\d.]+)\s*\|\s*Top-5:\s*([\d.]+)', line)
                        if top5_match:
                            top1_acc, top5_acc = top5_match.groups()
                            self.top1_accuracy = top1_acc
                            self.top5_accuracy = top5_acc
                            log_line = f"{current_time} | METRIC | Top-1: {top1_acc} | Top-5: {top5_acc}"
                        
                        # 4) Macro F1 점수: "Macro-F1: 0.387"
                        f1_match = re.search(r'Macro-F1:\s*([\d.]+)', line)
                        if f1_match:
                            macro_f1 = f1_match.groups()[0]
                            self.macro_f1 = macro_f1
                            log_line = f"{current_time} | METRIC | Macro-F1: {macro_f1}"
                        
                        # 5) 도메인별 지표 (확장됨): "Single: Top-1=0.523 | Top-5=0.672 | Macro-F1=0.387 | Combination: Top-1=0.342 | Top-5=0.523 | Macro-F1=0.298"
                        # 기존 단순 Single/Combination Top-1 패턴
                        domain_match = re.search(r'Single:\s*Top-1=([\d.]+)\s*\|\s*Combination:\s*Top-1=([\d.]+)', line)
                        if domain_match:
                            single_acc, combo_acc = domain_match.groups()
                            self.single_domain_acc = single_acc
                            self.combination_domain_acc = combo_acc
                            log_line = f"{current_time} | DOMAIN | Single: {single_acc} | Combination: {combo_acc}"
                                
                                # 확장된 Single 도메인 패턴 (Top-1/Top-5/Macro-F1)
                                single_extended_match = re.search(r'Single:\s*Top-1=([\d.]+)(?:\s*\|\s*Top-5=([\d.]+))?(?:\s*\|\s*Macro[- ]?F1=([\d.]+))?', line)
                                if single_extended_match:
                                    single_top1, single_top5, single_f1 = single_extended_match.groups()
                                    self.single_top1 = single_top1
                                    if single_top5:
                                        self.single_top5 = single_top5
                                    if single_f1:
                                        self.single_macro_f1 = single_f1
                                    log_line = f"{current_time} | DOMAIN_EXT | Single: T1={single_top1}" + \
                                              (f" T5={single_top5}" if single_top5 else "") + \
                                              (f" F1={single_f1}" if single_f1 else "")
                                
                                # 확장된 Combination 도메인 패턴 (Top-1/Top-5/Macro-F1)
                                combo_extended_match = re.search(r'Combination:\s*Top-1=([\d.]+)(?:\s*\|\s*Top-5=([\d.]+))?(?:\s*\|\s*Macro[- ]?F1=([\d.]+))?', line)
                                if combo_extended_match:
                                    combo_top1, combo_top5, combo_f1 = combo_extended_match.groups()
                                    self.combo_top1 = combo_top1
                                    if combo_top5:
                                        self.combo_top5 = combo_top5
                                    if combo_f1:
                                        self.combo_macro_f1 = combo_f1
                                    log_line = f"{current_time} | DOMAIN_EXT | Combo: T1={combo_top1}" + \
                                              (f" T5={combo_top5}" if combo_top5 else "") + \
                                              (f" F1={combo_f1}" if combo_f1 else "")
                                
                                # 6) 레이턴시 분해: "Pipeline: det=45ms, crop=12ms, cls=28ms, total=85ms"
                                latency_match = re.search(r'Pipeline:\s*det=([\d.]+)ms,\s*crop=([\d.]+)ms,\s*cls=([\d.]+)ms,\s*total=([\d.]+)ms', line)
                                if latency_match:
                                    det_latency, crop_latency, cls_latency, total_latency = latency_match.groups()
                                    self.det_latency = det_latency
                                    self.crop_latency = crop_latency
                                    self.cls_latency = cls_latency
                                    self.total_latency = total_latency
                                    log_line = f"{current_time} | LATENCY | Det: {det_latency}ms | Crop: {crop_latency}ms | Cls: {cls_latency}ms | Total: {total_latency}ms"
                                
                                # 7) Auto Confidence: "Auto-selected confidence: det=0.25, cls=0.30"
                                conf_match = re.search(r'Auto-selected confidence:\s*det=([\d.]+),\s*cls=([\d.]+)', line)
                                if conf_match:
                                    det_conf, cls_conf = conf_match.groups()
                                    self.det_confidence = det_conf
                                    self.cls_confidence = cls_conf
                                    log_line = f"{current_time} | CONFIDENCE | Detection: {det_conf} | Classification: {cls_conf}"
                                
                                # 8) OOM Guard 활성화: "OOM Guard: batch_size reduced 16→8, grad_accum 2→4"
                                oom_match = re.search(r'OOM Guard:\s*batch_size\s*reduced\s*(\d+)→(\d+),\s*grad_accum\s*(\d+)→(\d+)', line)
                                if oom_match:
                                    old_batch, new_batch, old_accum, new_accum = oom_match.groups()
                                    self.oom_old_batch = old_batch
                                    self.oom_new_batch = new_batch
                                    self.oom_old_accum = old_accum
                                    self.oom_new_accum = new_accum
                                    log_line = f"{current_time} | OOM | Batch: {old_batch}→{new_batch} | Accum: {old_accum}→{new_accum}"
                                
                                # 9) Interleaved Learning: "Interleaved: det_steps=1247, cls_steps=2491 (ratio=1:2.00)"
                                interleave_match = re.search(r'Interleaved:\s*det_steps=(\d+),\s*cls_steps=(\d+)\s*\(ratio=1:([\d.]+)\)', line)
                                if interleave_match:
                                    det_steps, cls_steps, ratio = interleave_match.groups()
                                    self.det_steps = det_steps
                                    self.cls_steps = cls_steps
                                    self.interleave_ratio = ratio
                                    log_line = f"{current_time} | INTERLEAVE | Det: {det_steps} | Cls: {cls_steps} | Ratio: 1:{ratio}"
                                
                                # === 새로운 요구사항 파서들 ===
                                
                                # 10) Detection Recall / Precision: "Recall: 0.623" "Precision: 0.578"
                                recall_match = re.search(r'Recall:\s*([\d.]+)', line)
                                if recall_match:
                                    recall_val = recall_match.groups()[0]
                                    self.det_recall = recall_val
                                    log_line = f"{current_time} | DET_METRIC | Recall: {recall_val}"
                                
                                precision_match = re.search(r'Precision:\s*([\d.]+)', line)
                                if precision_match:
                                    precision_val = precision_match.groups()[0]
                                    self.det_precision = precision_val
                                    log_line = f"{current_time} | DET_METRIC | Precision: {precision_val}"
                                
                                # 11) 도메인별 Selected Confidence: "Selected Confidence: single=0.24, combo=0.26"
                                selected_conf_match = re.search(r'Selected Confidence:\s*single=([\d.]+),\s*combo=([\d.]+)', line)
                                if selected_conf_match:
                                    conf_single, conf_combo = selected_conf_match.groups()
                                    self.selected_conf_single = conf_single
                                    self.selected_conf_combo = conf_combo
                                    log_line = f"{current_time} | CONF_DOMAIN | Single: {conf_single} | Combo: {conf_combo}"
                                
                                # 12) 레이턴시 퍼센타일: "Latency p50/p95/p99: det=12.3, crop=4.5, cls=15.2, total=32.0"
                                latency_percentile_match = re.search(
                                    r'Latency p50/p95/p99:\s*det=([\d.]+),\s*crop=([\d.]+),\s*cls=([\d.]+),\s*total=([\d.]+)', line
                                )
                                if latency_percentile_match:
                                    det_p, crop_p, cls_p, total_p = latency_percentile_match.groups()
                                    # 일단 p50 값으로 저장 (더 세밀한 분석은 추후 확장)
                                    self.latency_p50_det = det_p
                                    self.latency_p50_crop = crop_p
                                    self.latency_p50_cls = cls_p
                                    self.latency_p50_total = total_p
                                    log_line = f"{current_time} | LATENCY_P50 | Det: {det_p}ms | Crop: {crop_p}ms | Cls: {cls_p}ms | Total: {total_p}ms"
                                
                                # 13) VRAM Peak: "VRAM peak: 14500 MB"
                                vram_peak_match = re.search(r'VRAM peak:\s*(\d+)\s*MB', line)
                                if vram_peak_match:
                                    vram_peak = vram_peak_match.groups()[0]
                                    self.vram_peak_mb = vram_peak
                                    log_line = f"{current_time} | SYS_METRIC | VRAM Peak: {vram_peak}MB"
                                
                                # 14) Grad-Norm: "Grad-norm after_clipping: 1.23"
                                grad_norm_match = re.search(r'Grad[- ]?norm(?:\s*after_clipping)?:\s*([\d.]+)', line)
                                if grad_norm_match:
                                    grad_norm = grad_norm_match.groups()[0]
                                    self.grad_norm_after = grad_norm
                                    log_line = f"{current_time} | SYS_METRIC | Grad-Norm: {grad_norm}"
                                
                                # 15) 전체 에포크 자동 감지: 다양한 패턴 지원
                                epochs_patterns = [
                                    r'(?:Starting training for|will run for)\s+(\d+)\s+epochs?',
                                    r'Total epochs?[:\s]+(\d+)',
                                    r'Training for\s+(\d+)\s+epochs?',
                                    r'epochs?[=:\s]+(\d+)',
                                    r'(?:--epochs?|epochs)\s+(\d+)'
                                ]
                                
                                for pattern in epochs_patterns:
                                    epochs_match = re.search(pattern, line, re.IGNORECASE)
                                    if epochs_match:
                                        total_epochs = epochs_match.groups()[0]
                                        if int(total_epochs) > self.total_epochs:  # 더 큰 값만 업데이트
                                            self.total_epochs = int(total_epochs)
                                            log_line = f"{current_time} | CONFIG | Total Epochs: {total_epochs}"
                                        break
                                
                                # 16) 총 배치 수 자동 감지: "Batch 2000/5093" 패턴에서 최대값 추출
                                batch_total_match = re.search(r'Batch\s+\d+/(\d+)', line)
                                if batch_total_match:
                                    total_batches = batch_total_match.groups()[0]
                                    if int(total_batches) > self.total_batches:
                                        self.total_batches = int(total_batches)
                                        # 새로운 총 배치 수 발견시만 로그 생성
                                        if not hasattr(self, '_last_total_batches') or self._last_total_batches != self.total_batches:
                                            self._last_total_batches = self.total_batches
                                            log_line = f"{current_time} | CONFIG | Total Batches: {total_batches}"
                        
                        # 파싱된 데이터가 없으면 마지막 알려진 상태로 로그 생성
                        if not log_line:
                            log_line = f"{current_time} | INFO | Epoch {self.current_epoch} | Batch {self.current_batch} | Loss: {self.current_loss}"
                            
                    except Exception as parse_error:
                        # 파싱 실패시 기본 로그 생성
                        # KST 시간대로 로그 시간 표시 (수정됨)
                        kst = timezone(timedelta(hours=9))
                        current_time = datetime.now(kst).strftime('%H:%M:%S')
                        log_line = f"{current_time} | INFO | Epoch {self.current_epoch} | Batch {self.current_batch} | Loss: {self.current_loss}"
                        print(f"파싱 오류: {parse_error}")
                    
                    # WebSocket 전용 로그이므로 파일 기록 생략 (중복 방지)
                    
                    # WebSocket 클라이언트들에게 즉시 브로드캐스트 (동기화 문제 해결)
                    if self.connected_clients and log_line:
                        try:
                            # 직접 WebSocket 메시지 전송 (event loop 문제 해결)
                            message_data = {
                                "timestamp": current_time,
                                "message": log_line,
                                "type": "realtime",
                                "epoch": self.current_epoch,
                                "batch": self.current_batch,
                                "loss": self.current_loss,
                                "cls_acc": self.classification_acc,
                                "det_map": self.detection_map,
                                "epoch_time": self.epoch_time,
                                # Phase 1 새로운 메트릭들
                                "top1_accuracy": self.top1_accuracy,
                                "top5_accuracy": self.top5_accuracy,
                                "macro_f1": self.macro_f1,
                                "single_domain_acc": self.single_domain_acc,
                                "combination_domain_acc": self.combination_domain_acc,
                                "det_latency": self.det_latency,
                                "crop_latency": self.crop_latency,
                                "cls_latency": self.cls_latency,
                                "total_latency": self.total_latency,
                                "det_confidence": self.det_confidence,
                                "cls_confidence": self.cls_confidence,
                                "oom_old_batch": self.oom_old_batch,
                                "oom_new_batch": self.oom_new_batch,
                                "oom_old_accum": self.oom_old_accum,
                                "oom_new_accum": self.oom_new_accum,
                                "det_steps": self.det_steps,
                                "cls_steps": self.cls_steps,
                                "interleave_ratio": self.interleave_ratio,
                                # 동적 학습 설정
                                "total_epochs": self.total_epochs,
                                "total_batches": self.total_batches,
                                # 확장된 Phase 1 지표들 (새로운 요구사항)
                                # 도메인별 Top-5 / Macro-F1
                                "single_top1": self.single_top1,
                                "single_top5": self.single_top5,
                                "single_macro_f1": self.single_macro_f1,
                                "combo_top1": self.combo_top1,
                                "combo_top5": self.combo_top5,
                                "combo_macro_f1": self.combo_macro_f1,
                                # Detection Recall / Precision
                                "det_recall": self.det_recall,
                                "det_precision": self.det_precision,
                                # 도메인별 Selected Confidence
                                "selected_conf_single": self.selected_conf_single,
                                "selected_conf_combo": self.selected_conf_combo,
                                # 레이턴시 퍼센타일
                                "latency_p50_det": self.latency_p50_det,
                                "latency_p95_det": self.latency_p95_det,
                                "latency_p99_det": self.latency_p99_det,
                                "latency_p50_crop": self.latency_p50_crop,
                                "latency_p95_crop": self.latency_p95_crop,
                                "latency_p99_crop": self.latency_p99_crop,
                                "latency_p50_cls": self.latency_p50_cls,
                                "latency_p95_cls": self.latency_p95_cls,
                                "latency_p99_cls": self.latency_p99_cls,
                                "latency_p50_total": self.latency_p50_total,
                                "latency_p95_total": self.latency_p95_total,
                                "latency_p99_total": self.latency_p99_total,
                                # VRAM Peak / Grad-Norm
                                "vram_peak_mb": self.vram_peak_mb,
                                "grad_norm_after": self.grad_norm_after
                            }
                            
                            # 큐에 저장하여 메인 이벤트 루프에서 처리
                            if not hasattr(self, 'message_queue'):
                                import asyncio
                                self.message_queue = []
                            self.message_queue.append(message_data)
                            
                            print(f"🔄 [DEBUG] 파싱 성공: {log_line[:100]}...")
                            
                        except Exception as broadcast_error:
                            print(f"❌ WebSocket 브로드캐스트 오류: {broadcast_error}")
                    
                    elif self.connected_clients:
                        # 클라이언트가 연결되어 있지만 파싱된 로그가 없는 경우
                        print(f"⚠️  [DEBUG] 클라이언트 {len(self.connected_clients)}개 연결됨, 하지만 파싱 실패")
                    
                    time.sleep(1)  # 1초마다 업데이트
                    
                except Exception as e:
                    print(f"bash_23 캡처 오류: {e}")
                    time.sleep(2)
        
        # 백그라운드 스레드로 실행
        capture_thread = threading.Thread(target=capture_bash23, daemon=True)
        capture_thread.start()
        
    async def start_training_with_logging(self, command: List[str]):
        """학습 시작하면서 실시간 로그 캡처"""
        print(f"🚀 실시간 로그 캡처 시작: {' '.join(command)}")
        print(f"📁 로그 파일: {self.log_file}")
        
        # 연결된 클라이언트들에게 새 학습 시작 알림
        await self.broadcast_new_training_start()
        
        # tee 명령어로 stdout을 파일과 실시간 스트리밍에 동시 출력
        tee_command = ["tee", self.log_file]
        
        # 학습 프로세스 실행
        self.training_process = subprocess.Popen(
            command,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            universal_newlines=True,
            bufsize=0  # 라인 버퍼링
        )
        
        # 실시간 로그 읽기 및 브로드캐스트
        while True:
            if self.training_process.poll() is not None:
                # 프로세스 종료
                break
                
            line = self.training_process.stdout.readline()
            if line:
                # 파일에 저장
                with open(self.log_file, "a", encoding="utf-8") as f:
                    f.write(line)
                
                # 콘솔 출력
                print(line.rstrip())
                
                # WebSocket으로 브로드캐스트
                await self.broadcast_log(line.rstrip())
            
            await asyncio.sleep(0.01)  # CPU 사용률 조절
        
        return_code = self.training_process.returncode
        final_message = f"🏁 학습 완료 (종료 코드: {return_code})"
        print(final_message)
        await self.broadcast_log(final_message)
        
        return return_code
    
    async def broadcast_log(self, message: str):
        """모든 연결된 클라이언트에 로그 브로드캐스트"""
        if not self.connected_clients:
            return
            
        disconnect_clients = []
        for client in self.connected_clients:
            try:
                # KST 시간으로 통일
                kst = timezone(timedelta(hours=9))
                await client.send_text(json.dumps({
                    "timestamp": datetime.now(kst).isoformat(),
                    "message": message
                }))
            except:
                disconnect_clients.append(client)
        
        # 연결이 끊긴 클라이언트 제거
        for client in disconnect_clients:
            if client in self.connected_clients:
                self.connected_clients.remove(client)
    
    async def add_client(self, websocket: WebSocket):
        """새 클라이언트 연결"""
        await websocket.accept()
        self.connected_clients.append(websocket)
        
        # 새 학습 시작 메시지 전송 (기존 로그는 선택적으로만)
        try:
            kst = timezone(timedelta(hours=9))
            await websocket.send_text(json.dumps({
                "timestamp": datetime.now(kst).isoformat(),
                "message": "🔄 새로운 모니터링 세션 시작",
                "type": "session_start"
            }))
            
            # 활성 학습이 없으면 기존 로그 표시
            if not self.training_process or self.training_process.poll() is not None:
                historical_logs = await self.get_historical_logs()
                if historical_logs:
                    await websocket.send_text(json.dumps({
                        "timestamp": datetime.now(kst).isoformat(),
                        "message": "--- 📋 이전 세션 로그 (참조용) ---",
                        "type": "historical_header"
                    }))
                    for log in historical_logs[-50:]:  # 최근 50줄만
                        await websocket.send_text(json.dumps({
                            "timestamp": datetime.now(kst).isoformat(),
                            "message": log,
                            "historical": True
                        }))
                    await websocket.send_text(json.dumps({
                        "timestamp": datetime.now(kst).isoformat(),
                        "message": "--- 📋 이전 로그 끝 ---",
                        "type": "historical_footer"
                    }))
        except Exception as e:
            print(f"세션 시작 메시지 전송 실패: {e}")
            self.remove_client(websocket)
    
    async def get_historical_logs(self):
        """기존 학습 로그를 수집"""
        logs = []
        
        # 1) 실제 로그 파일들에서 전체 로그 읽기
        log_sources = [
            # 현재 설정된 로그 파일
            self.log_file,
            # 실제 학습 로그 파일
            "/home/max16/pillsnap_data/exp/exp01/logs/__main___20250823.log",
            "/tmp/pillsnap_training_20250823.log",
        ]
        
        for log_path in log_sources:
            if os.path.exists(log_path):
                try:
                    with open(log_path, "r", encoding="utf-8") as f:
                        for line in f:
                            logs.append(line.rstrip())
                    break  # 첫 번째로 발견된 로그 파일 사용
                except:
                    continue
        
        # 2) 로그가 없으면 가장 최신 로그 파일 자동 탐지
        if not logs:
            try:
                import glob
                pattern = "/home/max16/pillsnap_data/exp/exp01/logs/*main*_*.log"
                log_files = sorted(glob.glob(pattern), key=os.path.getmtime, reverse=True)
                
                if log_files:
                    latest_log = log_files[0]
                    print(f"📂 최신 로그 파일 사용: {latest_log}")
                    with open(latest_log, "r", encoding="utf-8") as f:
                        for line in f:
                            logs.append(line.rstrip())
            except:
                pass
        
        # 3) 여전히 로그가 없으면 기본 메시지
        if not logs:
            logs = [
                "📋 실시간 로그 스트리밍 대기 중...",
                "🔍 로그 파일을 찾을 수 없습니다.",
                "   새로운 학습이 시작되면 실시간으로 표시됩니다.",
                "",
                f"📁 모니터링 대상 로그 파일들:",
                f"   - {self.log_file}",
                f"   - /home/max16/pillsnap_data/exp/exp01/logs/__main___*.log",
            ]
        
        # 로그가 너무 길면 마지막 200줄만 반환
        return logs[-200:] if len(logs) > 200 else logs
    
    def remove_client(self, websocket: WebSocket):
        """클라이언트 연결 해제"""
        if websocket in self.connected_clients:
            self.connected_clients.remove(websocket)
    
    async def broadcast_new_training_start(self):
        """모든 클라이언트에게 새 학습 시작 알림"""
        if not self.connected_clients:
            return
            
        kst = timezone(timedelta(hours=9))
        message = {
            "timestamp": datetime.now(kst).isoformat(),
            "message": "🚀 새로운 학습 프로세스가 시작됩니다!",
            "type": "new_training_start"
        }
        
        disconnected = []
        for client in self.connected_clients:
            try:
                await client.send_text(json.dumps(message))
            except Exception:
                disconnected.append(client)
        
        # 연결이 끊어진 클라이언트 제거
        for client in disconnected:
            self.remove_client(client)

    async def watch_log_file(self):
        """실시간 로그 파일 감시 및 브로드캐스트"""
        if not Path(self.log_file).exists():
            print(f"로그 파일이 존재하지 않습니다: {self.log_file}")
            return
            
        print(f"📁 로그 파일 감시 시작: {self.log_file}")
        
        while True:
            try:
                # 메시지 큐 처리 (백그라운드 스레드에서 생성된 메시지)
                if hasattr(self, 'message_queue') and self.message_queue:
                    messages_to_send = self.message_queue.copy()
                    self.message_queue.clear()
                    
                    for message_data in messages_to_send:
                        await self.broadcast_to_clients(message_data)
                        print(f"📡 [DEBUG] WebSocket 전송: {message_data.get('message', '')[:50]}...")
                
                # 파일 크기 체크 (기존 로직 유지)
                current_size = Path(self.log_file).stat().st_size
                
                if current_size > self.last_position:
                    # 새로운 내용이 있음 - 읽기
                    with open(self.log_file, 'r', encoding='utf-8') as f:
                        f.seek(self.last_position)
                        new_lines = f.readlines()
                        self.last_position = f.tell()
                    
                    # 새로운 라인을 클라이언트들에게 전송 (백업 전송)
                    if new_lines and self.connected_clients:
                        kst = timezone(timedelta(hours=9))
                        for line in new_lines:
                            line = line.strip()
                            if line:  # 빈 줄 제외
                                await self.broadcast_to_clients({
                                    "timestamp": datetime.now(kst).isoformat(),
                                    "message": line,
                                    "type": "file_realtime"
                                })
                
                # 0.5초 대기 (더 빠른 응답)
                await asyncio.sleep(0.5)
                
            except Exception as e:
                print(f"로그 파일 감시 오류: {e}")
                await asyncio.sleep(2)  # 에러 시 2초 대기

    async def broadcast_to_clients(self, message: dict):
        """모든 연결된 클라이언트에게 메시지 브로드캐스트"""
        if not self.connected_clients:
            return
            
        disconnected = []
        for client in self.connected_clients:
            try:
                await client.send_text(json.dumps(message))
            except Exception:
                disconnected.append(client)
        
        # 연결이 끊어진 클라이언트 제거
        for client in disconnected:
            self.remove_client(client)

# 글로벌 로거 인스턴스
logger = RealtimeTrainingLogger()

# FastAPI 앱
app = FastAPI(title="실시간 학습 로그 스트리밍")

# HTML 대시보드
HTML_DASHBOARD = """
<!DOCTYPE html>
<html>
<head>
    <title>🚀 실시간 Stage 3 학습 모니터링</title>
    <meta charset="utf-8">
    <style>
        body { 
            font-family: Arial, sans-serif; 
            background: #1a1a1a; 
            color: #fff; 
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        .header {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
        }
        
        /* 상태 패널 */
        .status-panel {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        .status-card {
            background: #333;
            border-radius: 8px;
            padding: 20px;
            border: 2px solid #555;
        }
        .status-card.running { border-color: #00ff00; }
        .status-card.error { border-color: #ff0000; }
        
        /* 메트릭 패널 */
        .metrics-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .metric {
            background: #333;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #00ff00;
        }
        .metric-label {
            font-size: 12px;
            color: #aaa;
            margin-top: 5px;
        }
        .metric-change {
            font-size: 10px;
            margin-top: 3px;
        }
        .increasing { color: #ff9900; }
        .decreasing { color: #0099ff; }
        .stable { color: #666; }
        
        /* 학습 정보 패널 */
        .training-panel {
            background: #2a2a2a;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .training-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }
        .training-item {
            background: #333;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }
        .training-value {
            font-size: 18px;
            font-weight: bold;
            color: #ffff00;
        }
        
        /* 로그 컨테이너 */
        .log-container {
            background: #0a0a0a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 20px;
            height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.4;
        }
        .log-line {
            margin: 2px 0;
            padding: 2px 5px;
            border-radius: 3px;
        }
        .log-line.historical {
            color: #666;
            font-size: 12px;
        }
        .log-line.historical-separator {
            color: #888;
            font-weight: bold;
            background: #1a1a1a;
            border: 1px solid #444;
            text-align: center;
            margin: 5px 0;
        }
        .log-line.session-start {
            color: #00ff00;
            font-weight: bold;
            background: #002200;
            border: 1px solid #004400;
            text-align: center;
            margin: 10px 0;
        }
        .log-line.new {
            color: #00ff00;
            background: #003300;
            animation: flash 0.5s ease-out;
        }
        .log-line.config {
            color: #0099ff;
            background: #001122;
            font-weight: bold;
            border-left: 3px solid #0099ff;
            margin: 3px 0;
        }
        
        .connection-status {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #333;
            color: #fff;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 1000;
        }
        .connected { background: #006600; }
        .disconnected { background: #660000; }
        
        @keyframes flash {
            0% { background: #006600; }
            100% { background: #003300; }
        }
        
        .log-container::-webkit-scrollbar { width: 8px; }
        .log-container::-webkit-scrollbar-track { background: #111; }
        .log-container::-webkit-scrollbar-thumb { background: #333; border-radius: 4px; }
        
        .refresh-btn {
            background: #007700;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            margin-left: 10px;
        }
        .refresh-btn:hover { background: #009900; }
    </style>
</head>
<body>
    <div class="connection-status" id="connectionStatus">연결 중...</div>
    
    <div class="container">
        <div class="header">
            <h1>🚀 PillSnap Stage 3 Two-Stage 실시간 모니터링</h1>
            <p>실제 학습 프로세스 모니터링 + 실시간 로그 스트리밍</p>
            <button class="refresh-btn" onclick="location.reload()">새로고침</button>
        </div>
        
        <!-- 프로세스 상태 패널 -->
        <div class="status-panel">
            <div class="status-card" id="processStatus">
                <h3>🖥️ 프로세스 상태</h3>
                <div id="processInfo">확인 중...</div>
            </div>
            <div class="status-card" id="gpuStatus">
                <h3>🎮 GPU 상태</h3>
                <div id="gpuInfo">확인 중...</div>
            </div>
            <div class="status-card" id="timeStatus">
                <h3>⏱️ 시간 정보</h3>
                <div id="timeInfo">확인 중...</div>
            </div>
        </div>
        
        <!-- 시스템 메트릭 -->
        <div class="metrics-panel" id="metricsPanel">
            <!-- 동적으로 생성됩니다 -->
        </div>
        
        <!-- === Phase 1 새로운 메트릭 패널 === -->
        
        <!-- Top-1/Top-5 정확도 패널 -->
        <div class="training-panel">
            <h3>📊 정확도 지표 (Phase 1)</h3>
            <div class="training-grid">
                <div class="training-item">
                    <div class="training-value" id="top1Accuracy">-</div>
                    <div class="metric-label">Top-1 정확도</div>
                </div>
                <div class="training-item">
                    <div class="training-value" id="top5Accuracy">-</div>
                    <div class="metric-label">Top-5 정확도</div>
                </div>
                <div class="training-item">
                    <div class="training-value" id="macroF1">-</div>
                    <div class="metric-label">Macro F1</div>
                </div>
            </div>
        </div>
        
        <!-- 도메인 성능 패널 -->
        <div class="training-panel">
            <h3>🎯 도메인별 성능</h3>
            <div class="training-grid">
                <div class="training-item">
                    <div class="training-value" id="singleDomainAcc">-</div>
                    <div class="metric-label">Single 정확도</div>
                </div>
                <div class="training-item">
                    <div class="training-value" id="combinationDomainAcc">-</div>
                    <div class="metric-label">Combination 정확도</div>
                </div>
            </div>
        </div>
        
        <!-- 레이턴시 분해 패널 -->
        <div class="training-panel">
            <h3>⏱️ 레이턴시 분해</h3>
            <div class="training-grid">
                <div class="training-item">
                    <div class="training-value" id="detLatency">-</div>
                    <div class="metric-label">Detection (ms)</div>
                </div>
                <div class="training-item">
                    <div class="training-value" id="cropLatency">-</div>
                    <div class="metric-label">Crop (ms)</div>
                </div>
                <div class="training-item">
                    <div class="training-value" id="clsLatency">-</div>
                    <div class="metric-label">Classification (ms)</div>
                </div>
                <div class="training-item">
                    <div class="training-value" id="totalLatency">-</div>
                    <div class="metric-label">Total Pipeline (ms)</div>
                </div>
            </div>
        </div>
        
        <!-- Auto Confidence 패널 -->
        <div class="training-panel">
            <h3>🎯 Auto Confidence</h3>
            <div class="training-grid">
                <div class="training-item">
                    <div class="training-value" id="detConfidence">-</div>
                    <div class="metric-label">Detection Threshold</div>
                </div>
                <div class="training-item">
                    <div class="training-value" id="clsConfidence">-</div>
                    <div class="metric-label">Classification Threshold</div>
                </div>
            </div>
        </div>
        
        <!-- OOM Guard & Interleaved 패널 -->
        <div class="training-panel">
            <h3>🛪 시스템 최적화</h3>
            <div class="training-grid">
                <div class="training-item">
                    <div class="training-value" id="oomBatchSize">-</div>
                    <div class="metric-label">OOM Batch Size</div>
                </div>
                <div class="training-item">
                    <div class="training-value" id="oomGradAccum">-</div>
                    <div class="metric-label">OOM Grad Accum</div>
                </div>
                <div class="training-item">
                    <div class="training-value" id="detSteps">-</div>
                    <div class="metric-label">Detection Steps</div>
                </div>
                <div class="training-item">
                    <div class="training-value" id="clsSteps">-</div>
                    <div class="metric-label">Classification Steps</div>
                </div>
                <div class="training-item">
                    <div class="training-value" id="interleaveRatio">-</div>
                    <div class="metric-label">Interleave Ratio</div>
                </div>
                <div class="training-item">
                    <div class="training-value" id="vramPeakMb">-</div>
                    <div class="metric-label">VRAM Peak (MB)</div>
                </div>
                <div class="training-item">
                    <div class="training-value" id="gradNormAfter">-</div>
                    <div class="metric-label">Grad-Norm</div>
                </div>
            </div>
        </div>
        
        <!-- 학습 정보 패널 -->
        <div class="training-panel">
            <h3>🎯 학습 진행 상황</h3>
            <div class="training-grid" id="trainingGrid">
                <div class="training-item">
                    <div class="training-value" id="currentEpoch">-</div>
                    <div class="metric-label">현재 Epoch</div>
                </div>
                <div class="training-item">
                    <div class="training-value" id="currentBatch">-</div>
                    <div class="metric-label">현재 Batch</div>
                </div>
                <div class="training-item">
                    <div class="training-value" id="clsAccuracy">-</div>
                    <div class="metric-label">Classification 정확도</div>
                </div>
                <div class="training-item">
                    <div class="training-value" id="detMap">-</div>
                    <div class="metric-label">Detection mAP</div>
                </div>
                <div class="training-item">
                    <div class="training-value" id="epochTime">-</div>
                    <div class="metric-label">Epoch 시간</div>
                </div>
                <div class="training-item">
                    <div class="training-value" id="totalProgress">-</div>
                    <div class="metric-label">전체 진행률</div>
                </div>
            </div>
        </div>
        
        <!-- 실시간 로그 -->
        <div>
            <h3>📋 실시간 학습 로그</h3>
            <div class="log-container" id="logContainer">
                <div class="log-line">실시간 로그 연결 중...</div>
            </div>
        </div>
    </div>

    <script>
        let currentData = {};
        let logCount = 0;
        let latestEpoch = 0;
        let latestClsAcc = 0;
        let latestDetMap = 0;
        let totalEpochs = 50; // Stage 3 기본값 (동적 업데이트됨)
        let maxBatches = 5093; // 기본값 (동적 업데이트됨)
        
        // 시스템 모니터링 데이터 가져오기
        async function fetchSystemData() {
            try {
                const response = await fetch('/api/system');
                if (response.ok) {
                    currentData = await response.json();
                    updateSystemStatus();
                }
            } catch (error) {
                console.error('시스템 데이터 오류:', error);
            }
        }
        
        function updateSystemStatus() {
            if (currentData.status === 'running') {
                // 프로세스 상태
                document.getElementById('processStatus').className = 'status-card running';
                document.getElementById('processInfo').innerHTML = `
                    <strong>PID:</strong> ${currentData.process.pid}<br>
                    <strong>CPU:</strong> ${currentData.process.cpu_percent}%<br>
                    <strong>메모리:</strong> ${currentData.process.memory_gb}GB
                `;
                
                // GPU 상태
                if (currentData.gpu && !currentData.gpu.error) {
                    document.getElementById('gpuInfo').innerHTML = `
                        <strong>사용률:</strong> ${currentData.gpu.utilization}%<br>
                        <strong>메모리:</strong> ${currentData.gpu.memory_used_mb}MB<br>
                        <strong>온도:</strong> ${currentData.gpu.temperature}°C
                    `;
                }
                
                // 시간 정보
                const runtime = Math.floor(currentData.process.running_time / 60);
                document.getElementById('timeInfo').innerHTML = `
                    <strong>실행 시간:</strong> ${runtime}분<br>
                    <strong>업데이트:</strong> ${new Date(currentData.timestamp).toLocaleTimeString()}
                `;
                
                // 메트릭 패널 업데이트
                updateMetricsPanel();
            } else {
                document.getElementById('processStatus').className = 'status-card error';
                document.getElementById('processInfo').textContent = '학습 프로세스 없음';
            }
        }
        
        function updateMetricsPanel() {
            const metrics = currentData.changes || {};
            const metricsPanel = document.getElementById('metricsPanel');
            
            let metricsHtml = '';
            
            // 주요 메트릭들
            const metricConfigs = [
                { key: 'cpu_percent', label: 'CPU 사용률', value: currentData.process?.cpu_percent, unit: '%' },
                { key: 'memory_gb', label: 'RAM 사용량', value: currentData.process?.memory_gb, unit: 'GB' },
                { key: 'gpu_util', label: 'GPU 사용률', value: currentData.gpu?.utilization, unit: '%' },
                { key: 'gpu_memory', label: 'GPU 메모리', value: currentData.gpu?.memory_used_mb, unit: 'MB' },
                { key: 'gpu_temp', label: 'GPU 온도', value: currentData.gpu?.temperature, unit: '°C' }
            ];
            
            metricConfigs.forEach(config => {
                if (config.value !== undefined) {
                    const change = metrics[config.key];
                    const changeClass = change ? change.trend : 'stable';
                    const changeText = change ? `${change.trend} (${change.change > 0 ? '+' : ''}${change.change})` : '';
                    
                    metricsHtml += `
                        <div class="metric">
                            <div class="metric-value">${config.value}${config.unit}</div>
                            <div class="metric-label">${config.label}</div>
                            <div class="metric-change ${changeClass}">${changeText}</div>
                        </div>
                    `;
                }
            });
            
            metricsPanel.innerHTML = metricsHtml;
        }
        
        function updateTrainingInfo(message) {
            // Epoch 정보 추출 및 총 에포크 자동 감지
            const epochMatch = message.match(/Epoch\s+(\d+)/i);
            if (epochMatch) {
                latestEpoch = parseInt(epochMatch[1]);
                document.getElementById('currentEpoch').textContent = latestEpoch;
                
                // 총 에포크 자동 감지 ("Starting training for X epochs" 패턴)
                const totalEpochMatch = message.match(/(?:Starting training for|Total epochs?)\s+(\d+)\s+epochs?/i);
                if (totalEpochMatch) {
                    totalEpochs = parseInt(totalEpochMatch[1]);
                    console.log(`📊 총 에포크 감지: ${totalEpochs}`);
                }
                
                // Stage별 기본 에포크 추정 (로그에 명시되지 않은 경우)
                if (message.includes('Stage 3') || message.includes('stage3')) {
                    totalEpochs = Math.max(totalEpochs, 50); // Stage 3: 최소 50 에포크
                } else if (message.includes('Stage 4') || message.includes('stage4')) {
                    totalEpochs = Math.max(totalEpochs, 100); // Stage 4: 최소 100 에포크
                }
                
                const progress = Math.round((latestEpoch / totalEpochs) * 100);
                document.getElementById('totalProgress').textContent = `${progress}%`;
            }
            
            // Classification 정확도 추출
            const clsMatch = message.match(/Cls Acc:\s*([\d.]+)/i);
            if (clsMatch) {
                latestClsAcc = parseFloat(clsMatch[1]);
                document.getElementById('clsAccuracy').textContent = `${(latestClsAcc * 100).toFixed(1)}%`;
            }
            
            // Detection mAP 추출
            const detMatch = message.match(/Det mAP:\s*([\d.]+)/i);
            if (detMatch) {
                latestDetMap = parseFloat(detMatch[1]);
                document.getElementById('detMap').textContent = `${(latestDetMap * 100).toFixed(1)}%`;
            }
            
            // 시간 정보 추출
            const timeMatch = message.match(/Time:\s*([\d.]+)s/i);
            if (timeMatch) {
                const seconds = parseFloat(timeMatch[1]);
                const minutes = Math.floor(seconds / 60);
                document.getElementById('epochTime').textContent = `${minutes}분 ${Math.floor(seconds % 60)}초`;
            }
            
            // Batch 정보 추출 및 총 배치 자동 감지
            const batchMatch = message.match(/Batch\s+(\d+)(?:/(\d+))?/i);
            if (batchMatch) {
                const currentBatch = parseInt(batchMatch[1]);
                const totalBatch = batchMatch[2] ? parseInt(batchMatch[2]) : maxBatches;
                
                if (batchMatch[2]) {
                    maxBatches = totalBatch; // 총 배치 수 업데이트
                }
                
                document.getElementById('currentBatch').textContent = `${currentBatch}/${maxBatches}`;
                
                // 배치 진행률 계산
                const batchProgress = Math.round((currentBatch / maxBatches) * 100);
                
                // 전체 진행률 계산 (에포크 + 현재 에포크 내 배치 진행률)
                const epochProgress = ((latestEpoch - 1) / totalEpochs) * 100;
                const currentEpochProgress = (batchProgress / totalEpochs);
                const overallProgress = Math.round(epochProgress + currentEpochProgress);
                
                document.getElementById('totalProgress').textContent = `${overallProgress}%`;
            }
        }
        
        // 실시간 지표 업데이트 함수 (확장됨)
        function updateMetricsDisplay(metrics) {
            // === 기존 메트릭 ===
            // 현재 에포크 (동적 총 에포크 표시)
            const epochElement = document.getElementById('current-epoch');
            if (epochElement) epochElement.textContent = metrics.epoch + '/' + totalEpochs;
            
            // 현재 배치
            const batchElement = document.getElementById('current-batch');
            if (batchElement) batchElement.textContent = metrics.batch;
            
            // 현재 Loss
            const lossElement = document.getElementById('current-loss');
            if (lossElement) lossElement.textContent = metrics.loss;
            
            // Classification 정확도
            const clsAccElement = document.getElementById('cls-accuracy');
            if (clsAccElement) clsAccElement.textContent = metrics.cls_acc;
            
            // Detection mAP
            const detMapElement = document.getElementById('det-map');
            if (detMapElement) detMapElement.textContent = metrics.det_map;
            
            // Epoch 시간
            const epochTimeElement = document.getElementById('epoch-time');
            if (epochTimeElement) epochTimeElement.textContent = metrics.epoch_time;
            
            // 상태 업데이트
            const statusElement = document.getElementById('training-status');
            if (statusElement) {
                statusElement.textContent = `Epoch ${metrics.epoch} | Batch ${metrics.batch} | Loss: ${metrics.loss}`;
                statusElement.className = 'training-value running';
            }
            
            // === Phase 1 새로운 메트릭 ===
            
            // Top-1/Top-5 정확도
            if (metrics.top1_accuracy && metrics.top1_accuracy !== 'N/A') {
                const top1Element = document.getElementById('top1Accuracy');
                if (top1Element) {
                    const percentage = (parseFloat(metrics.top1_accuracy) * 100).toFixed(1);
                    top1Element.textContent = `${percentage}%`;
                    top1Element.style.color = parseFloat(metrics.top1_accuracy) > 0.4 ? '#00ff00' : '#ff9900';
                }
            }
            
            if (metrics.top5_accuracy && metrics.top5_accuracy !== 'N/A') {
                const top5Element = document.getElementById('top5Accuracy');
                if (top5Element) {
                    const percentage = (parseFloat(metrics.top5_accuracy) * 100).toFixed(1);
                    top5Element.textContent = `${percentage}%`;
                    top5Element.style.color = parseFloat(metrics.top5_accuracy) > 0.6 ? '#00ff00' : '#ff9900';
                }
            }
            
            // Macro F1
            if (metrics.macro_f1 && metrics.macro_f1 !== 'N/A') {
                const f1Element = document.getElementById('macroF1');
                if (f1Element) {
                    const percentage = (parseFloat(metrics.macro_f1) * 100).toFixed(1);
                    f1Element.textContent = `${percentage}%`;
                    f1Element.style.color = parseFloat(metrics.macro_f1) > 0.3 ? '#00ff00' : '#ff9900';
                }
            }
            
            // 도메인별 성능
            if (metrics.single_domain_acc && metrics.single_domain_acc !== 'N/A') {
                const singleElement = document.getElementById('singleDomainAcc');
                if (singleElement) {
                    const percentage = (parseFloat(metrics.single_domain_acc) * 100).toFixed(1);
                    singleElement.textContent = `${percentage}%`;
                    singleElement.style.color = parseFloat(metrics.single_domain_acc) > 0.5 ? '#00ff00' : '#ff9900';
                }
            }
            
            if (metrics.combination_domain_acc && metrics.combination_domain_acc !== 'N/A') {
                const comboElement = document.getElementById('combinationDomainAcc');
                if (comboElement) {
                    const percentage = (parseFloat(metrics.combination_domain_acc) * 100).toFixed(1);
                    comboElement.textContent = `${percentage}%`;
                    comboElement.style.color = parseFloat(metrics.combination_domain_acc) > 0.3 ? '#00ff00' : '#ff9900';
                }
            }
            
            // 레이턴시 분해
            const latencyMetrics = [
                { id: 'detLatency', key: 'det_latency', threshold: 50 },
                { id: 'cropLatency', key: 'crop_latency', threshold: 20 },
                { id: 'clsLatency', key: 'cls_latency', threshold: 30 },
                { id: 'totalLatency', key: 'total_latency', threshold: 100 }
            ];
            
            latencyMetrics.forEach(metric => {
                if (metrics[metric.key] && metrics[metric.key] !== 'N/A') {
                    const element = document.getElementById(metric.id);
                    if (element) {
                        const value = parseFloat(metrics[metric.key]);
                        element.textContent = `${value}ms`;
                        element.style.color = value < metric.threshold ? '#00ff00' : '#ff9900';
                    }
                }
            });
            
            // Auto Confidence (도메인별 Selected Confidence 추가)
            if (metrics.det_confidence && metrics.det_confidence !== 'N/A') {
                const detConfElement = document.getElementById('detConfidence');
                if (detConfElement) {
                    detConfElement.textContent = metrics.det_confidence;
                    detConfElement.style.color = '#00ff00';
                }
            }
            
            if (metrics.cls_confidence && metrics.cls_confidence !== 'N/A') {
                const clsConfElement = document.getElementById('clsConfidence');
                if (clsConfElement) {
                    clsConfElement.textContent = metrics.cls_confidence;
                    clsConfElement.style.color = '#00ff00';
                }
            }
            
            // 도메인별 Selected Confidence (새로운 요구사항)
            if (metrics.selected_conf_single && metrics.selected_conf_single !== 'N/A') {
                const selectedConfSingleElement = document.getElementById('selectedConfSingle');
                if (selectedConfSingleElement) {
                    selectedConfSingleElement.textContent = metrics.selected_conf_single;
                    selectedConfSingleElement.style.color = '#00ff00';
                }
            }
            
            if (metrics.selected_conf_combo && metrics.selected_conf_combo !== 'N/A') {
                const selectedConfComboElement = document.getElementById('selectedConfCombo');
                if (selectedConfComboElement) {
                    selectedConfComboElement.textContent = metrics.selected_conf_combo;
                    selectedConfComboElement.style.color = '#00ff00';
                }
            }
            
            // OOM Guard 정보
            if (metrics.oom_new_batch && metrics.oom_new_batch !== 'N/A') {
                const oomBatchElement = document.getElementById('oomBatchSize');
                if (oomBatchElement) {
                    oomBatchElement.textContent = `${metrics.oom_old_batch}→${metrics.oom_new_batch}`;
                    oomBatchElement.style.color = '#ff9900'; // OOM 발생 경고 색상
                }
            }
            
            if (metrics.oom_new_accum && metrics.oom_new_accum !== 'N/A') {
                const oomAccumElement = document.getElementById('oomGradAccum');
                if (oomAccumElement) {
                    oomAccumElement.textContent = `${metrics.oom_old_accum}→${metrics.oom_new_accum}`;
                    oomAccumElement.style.color = '#ff9900'; // OOM 발생 경고 색상
                }
            }
            
            // Interleaved Learning
            if (metrics.det_steps && metrics.det_steps !== 'N/A') {
                const detStepsElement = document.getElementById('detSteps');
                if (detStepsElement) {
                    detStepsElement.textContent = metrics.det_steps;
                    detStepsElement.style.color = '#00ff00';
                }
            }
            
            if (metrics.cls_steps && metrics.cls_steps !== 'N/A') {
                const clsStepsElement = document.getElementById('clsSteps');
                if (clsStepsElement) {
                    clsStepsElement.textContent = metrics.cls_steps;
                    clsStepsElement.style.color = '#00ff00';
                }
            }
            
            if (metrics.interleave_ratio && metrics.interleave_ratio !== 'N/A') {
                const ratioElement = document.getElementById('interleaveRatio');
                if (ratioElement) {
                    ratioElement.textContent = `1:${metrics.interleave_ratio}`;
                    const ratio = parseFloat(metrics.interleave_ratio);
                    ratioElement.style.color = Math.abs(ratio - 2.0) < 0.2 ? '#00ff00' : '#ff9900'; // 1:2 목표비율 근사 체크
                }
            }
            
            // === 새로운 요구사항 메트릭들 ===
            
            // 도메인별 Top-1/Top-5/Macro-F1
            const domainMetrics = [
                { key: 'single_top1', id: 'singleTop1', threshold: 0.5 },
                { key: 'single_top5', id: 'singleTop5', threshold: 0.7 },
                { key: 'single_macro_f1', id: 'singleMacroF1', threshold: 0.4 },
                { key: 'combo_top1', id: 'comboTop1', threshold: 0.3 },
                { key: 'combo_top5', id: 'comboTop5', threshold: 0.5 },
                { key: 'combo_macro_f1', id: 'comboMacroF1', threshold: 0.3 }
            ];
            
            domainMetrics.forEach(metric => {
                if (metrics[metric.key] && metrics[metric.key] !== 'N/A') {
                    const element = document.getElementById(metric.id);
                    if (element) {
                        const value = parseFloat(metrics[metric.key]);
                        const percentage = (value * 100).toFixed(1);
                        element.textContent = `${percentage}%`;
                        element.style.color = value > metric.threshold ? '#00ff00' : '#ff9900';
                    }
                }
            });
            
            // Detection Recall / Precision
            if (metrics.det_recall && metrics.det_recall !== 'N/A') {
                const recallElement = document.getElementById('detRecall');
                if (recallElement) {
                    const percentage = (parseFloat(metrics.det_recall) * 100).toFixed(1);
                    recallElement.textContent = `${percentage}%`;
                    recallElement.style.color = parseFloat(metrics.det_recall) > 0.6 ? '#00ff00' : '#ff9900';
                }
            }
            
            if (metrics.det_precision && metrics.det_precision !== 'N/A') {
                const precisionElement = document.getElementById('detPrecision');
                if (precisionElement) {
                    const percentage = (parseFloat(metrics.det_precision) * 100).toFixed(1);
                    precisionElement.textContent = `${percentage}%`;
                    precisionElement.style.color = parseFloat(metrics.det_precision) > 0.6 ? '#00ff00' : '#ff9900';
                }
            }
            
            // 레이턴시 퍼센타일 (p50)
            const latencyP50Metrics = [
                { key: 'latency_p50_det', id: 'detLatencyP50', threshold: 50 },
                { key: 'latency_p50_crop', id: 'cropLatencyP50', threshold: 20 },
                { key: 'latency_p50_cls', id: 'clsLatencyP50', threshold: 30 },
                { key: 'latency_p50_total', id: 'totalLatencyP50', threshold: 100 }
            ];
            
            latencyP50Metrics.forEach(metric => {
                if (metrics[metric.key] && metrics[metric.key] !== 'N/A') {
                    const element = document.getElementById(metric.id);
                    if (element) {
                        const value = parseFloat(metrics[metric.key]);
                        element.textContent = `${value}ms`;
                        element.style.color = value < metric.threshold ? '#00ff00' : '#ff9900';
                    }
                }
            });
            
            // VRAM Peak / Grad-Norm
            if (metrics.vram_peak_mb && metrics.vram_peak_mb !== 'N/A') {
                const vramElement = document.getElementById('vramPeakMb');
                if (vramElement) {
                    const value = parseInt(metrics.vram_peak_mb);
                    vramElement.textContent = `${value}MB`;
                    vramElement.style.color = value < 14000 ? '#00ff00' : '#ff9900'; // 14GB 임계점
                }
            }
            
            if (metrics.grad_norm_after && metrics.grad_norm_after !== 'N/A') {
                const gradElement = document.getElementById('gradNormAfter');
                if (gradElement) {
                    const value = parseFloat(metrics.grad_norm_after);
                    gradElement.textContent = value.toFixed(3);
                    gradElement.style.color = value < 5.0 ? '#00ff00' : '#ff9900'; // Gradient clipping 임계
                }
            }
        }
        
        // WebSocket 연결
        const ws = new WebSocket(`ws://${window.location.host}/ws`);
        
        ws.onopen = function(event) {
            document.getElementById('connectionStatus').textContent = '✅ 로그 연결됨';
            document.getElementById('connectionStatus').className = 'connection-status connected';
        };
        
        ws.onmessage = function(event) {
            const data = JSON.parse(event.data);
            const logLine = document.createElement('div');
            
            // 새로운 실시간 지표 업데이트 (확장됨)
            if (data.type === 'realtime' && data.epoch && data.batch && data.loss) {
                // 지표 업데이트 (기존 + Phase 1 새로운 메트릭)
                updateMetricsDisplay({
                    // 기존 메트릭
                    epoch: data.epoch,
                    batch: data.batch, 
                    loss: data.loss,
                    cls_acc: data.cls_acc || 'N/A',
                    det_map: data.det_map || 'N/A',
                    epoch_time: data.epoch_time || 'N/A',
                    // Phase 1 새로운 메트릭
                    top1_accuracy: data.top1_accuracy || 'N/A',
                    top5_accuracy: data.top5_accuracy || 'N/A',
                    macro_f1: data.macro_f1 || 'N/A',
                    single_domain_acc: data.single_domain_acc || 'N/A',
                    combination_domain_acc: data.combination_domain_acc || 'N/A',
                    det_latency: data.det_latency || 'N/A',
                    crop_latency: data.crop_latency || 'N/A',
                    cls_latency: data.cls_latency || 'N/A',
                    total_latency: data.total_latency || 'N/A',
                    det_confidence: data.det_confidence || 'N/A',
                    cls_confidence: data.cls_confidence || 'N/A',
                    oom_old_batch: data.oom_old_batch || 'N/A',
                    oom_new_batch: data.oom_new_batch || 'N/A',
                    oom_old_accum: data.oom_old_accum || 'N/A',
                    oom_new_accum: data.oom_new_accum || 'N/A',
                    det_steps: data.det_steps || 'N/A',
                    cls_steps: data.cls_steps || 'N/A',
                    interleave_ratio: data.interleave_ratio || 'N/A',
                    // 새로운 요구사항 메트릭들
                    single_top1: data.single_top1 || 'N/A',
                    single_top5: data.single_top5 || 'N/A',
                    single_macro_f1: data.single_macro_f1 || 'N/A',
                    combo_top1: data.combo_top1 || 'N/A',
                    combo_top5: data.combo_top5 || 'N/A',
                    combo_macro_f1: data.combo_macro_f1 || 'N/A',
                    det_recall: data.det_recall || 'N/A',
                    det_precision: data.det_precision || 'N/A',
                    selected_conf_single: data.selected_conf_single || 'N/A',
                    selected_conf_combo: data.selected_conf_combo || 'N/A',
                    latency_p50_det: data.latency_p50_det || 'N/A',
                    latency_p50_crop: data.latency_p50_crop || 'N/A',
                    latency_p50_cls: data.latency_p50_cls || 'N/A',
                    latency_p50_total: data.latency_p50_total || 'N/A',
                    vram_peak_mb: data.vram_peak_mb || 'N/A',
                    grad_norm_after: data.grad_norm_after || 'N/A'
                });
                
                // 동적 설정 업데이트
                if (data.total_epochs && data.total_epochs !== 'N/A') {
                    totalEpochs = parseInt(data.total_epochs);
                    console.log(`📊 총 에포크 업데이트: ${totalEpochs}`);
                }
                
                if (data.total_batches && data.total_batches !== 'N/A') {
                    maxBatches = parseInt(data.total_batches);
                    console.log(`📊 총 배치 업데이트: ${maxBatches}`);
                }
                
                logLine.className = 'log-line realtime';
            } else if (data.type === 'realtime' && (data.total_epochs || data.total_batches)) {
                // 설정 정보만 받은 경우 (CONFIG 로그)
                if (data.total_epochs && data.total_epochs !== 'N/A') {
                    totalEpochs = parseInt(data.total_epochs);
                    console.log(`📊 총 에포크 설정: ${totalEpochs}`);
                }
                
                if (data.total_batches && data.total_batches !== 'N/A') {
                    maxBatches = parseInt(data.total_batches);
                    console.log(`📊 총 배치 설정: ${maxBatches}`);
                }
                
                // 현재 UI 업데이트 (에포크/진행률 재계산)
                if (latestEpoch > 0) {
                    const progress = Math.round((latestEpoch / totalEpochs) * 100);
                    document.getElementById('totalProgress').textContent = `${progress}%`;
                    
                    const epochElement = document.getElementById('current-epoch');
                    if (epochElement) epochElement.textContent = latestEpoch + '/' + totalEpochs;
                }
                
                logLine.className = 'log-line config';
            } else if (data.type === 'session_start') {
                logLine.className = 'log-line session-start';
                logContainer.innerHTML = '';
            } else if (data.type === 'new_training_start') {
                logLine.className = 'log-line session-start';
                logContainer.innerHTML = '<div class="log-line historical-separator">--- 이전 세션 종료 ---</div>';
            } else if (data.type === 'historical_header' || data.type === 'historical_footer') {
                logLine.className = 'log-line historical-separator';
            } else if (data.historical) {
                logLine.className = 'log-line historical';
            } else {
                logLine.className = 'log-line new';
            }
            
            logLine.textContent = data.message;
            
            // 기존 학습 정보 업데이트 (하위 호환성)
            updateTrainingInfo(data.message);
            
            document.getElementById('logContainer').appendChild(logLine);
            document.getElementById('logContainer').scrollTop = document.getElementById('logContainer').scrollHeight;
            
            // 로그 개수 제한
            logCount++;
            if (logCount > 1000) {
                const firstChild = document.getElementById('logContainer').firstChild;
                if (firstChild) {
                    document.getElementById('logContainer').removeChild(firstChild);
                    logCount--;
                }
            }
        };
        
        ws.onclose = function(event) {
            document.getElementById('connectionStatus').textContent = '❌ 로그 연결 끊김';
            document.getElementById('connectionStatus').className = 'connection-status disconnected';
        };
        
        // 시스템 데이터 주기적 업데이트 (1초마다)
        setInterval(fetchSystemData, 1000);
        fetchSystemData(); // 즉시 첫 업데이트
    </script>
</body>
</html>
"""

@app.get("/")
async def get_dashboard():
    """실시간 로그 대시보드"""
    return HTMLResponse(HTML_DASHBOARD)

@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    """WebSocket 엔드포인트"""
    await logger.add_client(websocket)
    try:
        while True:
            await websocket.receive_text()  # 연결 유지
    except WebSocketDisconnect:
        logger.remove_client(websocket)

@app.get("/api/system")
async def get_system_status():
    """시스템 상태 API (기존 simple_real_monitor.py와 호환)"""
    try:
        import psutil
        import subprocess
        
        # 학습 프로세스 찾기
        training_pid = None
        for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
            try:
                if proc.info['name'] == 'python':
                    cmdline = ' '.join(proc.info['cmdline'])
                    if 'train_stage3_two_stage' in cmdline:
                        training_pid = proc.info['pid']
                        break
            except:
                continue
        
        if not training_pid:
            return {"status": "not_running", "message": "학습 프로세스를 찾을 수 없음"}
        
        # 프로세스 정보
        process = psutil.Process(training_pid)
        cpu_percent = process.cpu_percent(interval=0.1)
        memory_info = process.memory_info()
        memory_gb = memory_info.rss / (1024**3)
        
        # GPU 정보
        gpu_info = {}
        try:
            result = subprocess.run([
                'nvidia-smi', 
                '--query-gpu=utilization.gpu,memory.used,memory.total,temperature.gpu',
                '--format=csv,noheader,nounits'
            ], capture_output=True, text=True, timeout=5)
            
            if result.returncode == 0:
                values = result.stdout.strip().split(', ')
                gpu_info = {
                    "utilization": int(values[0]),
                    "memory_used_mb": int(values[1]),
                    "memory_total_mb": int(values[2]),
                    "temperature": int(values[3])
                }
        except:
            gpu_info = {"error": "GPU 정보 읽기 실패"}
        
        # KST 시간 설정
        kst = timezone(timedelta(hours=9))
        return {
            "status": "running",
            "timestamp": datetime.now(kst).isoformat(),
            "process": {
                "pid": training_pid,
                "cpu_percent": cpu_percent,
                "memory_gb": round(memory_gb, 2),
                "running_time": time.time() - process.create_time()
            },
            "gpu": gpu_info,
            "message": f"실제 학습 진행 중 (PID: {training_pid})"
        }
        
    except Exception as e:
        kst = timezone(timedelta(hours=9))
        return {
            "status": "error", 
            "message": f"시스템 상태 오류: {e}",
            "timestamp": datetime.now(kst).isoformat()
        }

@app.post("/start_training")
async def start_training(command: List[str]):
    """학습 시작 API"""
    asyncio.create_task(logger.start_training_with_logging(command))
    return {"status": "started", "command": command, "log_file": logger.log_file}

if __name__ == "__main__":
    import argparse
    
    parser = argparse.ArgumentParser(description="실시간 학습 로그 스트리밍")
    parser.add_argument("--port", type=int, default=8000, help="서버 포트")
    parser.add_argument("--command", nargs="+", help="실행할 학습 명령어")
    
    args = parser.parse_args()
    
    print(f"🚀 실시간 로그 서버 시작 (포트: {args.port})")
    print(f"📊 브라우저에서 http://localhost:{args.port} 접속")
    print(f"📝 감지된 로그 파일: {logger.log_file}")
    
    if args.command:
        # 명령어가 주어진 경우 바로 학습 시작
        async def start_training_on_startup():
            await asyncio.sleep(1)  # 서버 시작 대기
            await logger.start_training_with_logging(args.command)
        
        asyncio.create_task(start_training_on_startup())
    
    # FastAPI 이벤트 핸들러로 파일 감시 태스크 등록
    @app.on_event("startup")
    async def on_startup():
        print(f"📁 로그 파일 감시 태스크 시작: {logger.log_file}")
        asyncio.create_task(logger.watch_log_file())
    
    uvicorn.run(app, host="0.0.0.0", port=args.port, log_level="warning")